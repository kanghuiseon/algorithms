# 알고리즘 설명! (골드) (스터디용은 제외)
## 16236. 아기 상어 (골드 4)
어렵다… 응용이 왜이렇게 안될까… 열심히 풀어야겠다….ㅠㅠ

### 구현
1. 현재 위치에서 bfs 하기
2. bfs에서 먹을 수 있는 물고기를 eating vector에 넣는다.
3. 만약 0이거나 사이즈가 같으면 그냥 check만 해주고 queue에만 넣는다.
4. bfs가 끝나면 check배열 초기화하고 만약 eating 배열이 비어있지 않다면 (먹을게 있다면) eat++, tt+=eating[0].first, 먹은 곳은 0으로 처리해주고 아기 상어의 위치도 현재 먹은 위치로 업데이트 해준다.

여기서 tt는 전체 걸린 시간인데, 전역으로 tt++을 해줬더니 같은 시간으로 이동했지만 다른 위치에 있는 경우에 먼저 본 경우가 시간이 더 짧은 경우가 생겼다.

그래서 queue<pair<**int**, pair<**int**, **int**>>> q; 로 queue를 선언하고 가장 앞의 부분을 time으로 넣어주고, eating배열에 넣을 때 시간도 같이 넣어줘서 eating배열에서 뺄때 tt값을 더해줬다.

6. 만약 eating배열이 비었다면 더 이상 먹을게 없다는 말이니까 while문을 나간다.

### 사족
처음에 풀때 엄청 헤맸다. 한번의 bfs로 어떻게든 해보려고 용쓰다가 못하겠어서 거의 포기 직전까지 갔었다….

체크배열을 사용하면 이전에 체크되어 있는 곳은 못가고 체크 배열을 사용하지 않으면 무한루프돌고…..

친구가 그럼 체크배열을 초기화하고 다시 bfs를 돌면 어때? 라고 해주지 않았다면 시간이 오래 지나고 난 후에야 풀 수 있었을 것이다….

고착된 방식에서 머물러 있지 않고 방식의 추가나 제거에 대해서 좀 더 넓게 생각해야겠다는 생각(?)을 했다.
