# 알고리즘 설명! (골드) (스터디용은 제외)
## 16236. 아기 상어 (골드 4)
어렵다… 응용이 왜이렇게 안될까… 열심히 풀어야겠다….ㅠㅠ

### 구현
1. 현재 위치에서 bfs 하기
2. bfs에서 먹을 수 있는 물고기를 eating vector에 넣는다.
3. 만약 0이거나 사이즈가 같으면 그냥 check만 해주고 queue에만 넣는다.
4. bfs가 끝나면 check배열 초기화하고 만약 eating 배열이 비어있지 않다면 (먹을게 있다면) eat++, tt+=eating[0].first, 먹은 곳은 0으로 처리해주고 아기 상어의 위치도 현재 먹은 위치로 업데이트 해준다.

여기서 tt는 전체 걸린 시간인데, 전역으로 tt++을 해줬더니 같은 시간으로 이동했지만 다른 위치에 있는 경우에 먼저 본 경우가 시간이 더 짧은 경우가 생겼다.

그래서 queue<pair<**int**, pair<**int**, **int**>>> q; 로 queue를 선언하고 가장 앞의 부분을 time으로 넣어주고, eating배열에 넣을 때 시간도 같이 넣어줘서 eating배열에서 뺄때 tt값을 더해줬다.

6. 만약 eating배열이 비었다면 더 이상 먹을게 없다는 말이니까 while문을 나간다.

### 사족
처음에 풀때 엄청 헤맸다. 한번의 bfs로 어떻게든 해보려고 용쓰다가 못하겠어서 거의 포기 직전까지 갔었다….

체크배열을 사용하면 이전에 체크되어 있는 곳은 못가고 체크 배열을 사용하지 않으면 무한루프돌고…..

친구가 그럼 체크배열을 초기화하고 다시 bfs를 돌면 어때? 라고 해주지 않았다면 시간이 오래 지나고 난 후에야 풀 수 있었을 것이다….

고착된 방식에서 머물러 있지 않고 방식의 추가나 제거에 대해서 좀 더 넓게 생각해야겠다는 생각(?)을 했다.



## 15683. 감시 (골드 5)
처음에는 현재의 cctv위치 사방을 보고 최대로 많이 볼 수 있는 방향으로 cctv의 방향을 설정했다. (모든 cctv에 대해서)

이렇게 하면 현재는 가장 많이 0을 채울 수 있을 지는 몰라도 전체적으로 봤을때는 최적의 답이 아닐 수 있게 된다.
```cpp
반례
4 6
2 6 0 3 0 2
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 6 1
8
```

그래서 dfs를 이용해서 전체의 경우의 수를 봐서 완전탐색으로 문제를 풀었다.
```cpp
case 4:
        fill_cctv(x, y, 0);
        fill_cctv(x, y, 1);
        fill_cctv(x, y, 3);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        fill_cctv(x, y, 0);
        fill_cctv(x, y, 2);
        fill_cctv(x, y, 3);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        fill_cctv(x, y, 0);
        fill_cctv(x, y, 1);
        fill_cctv(x, y, 2);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        fill_cctv(x, y, 1);
        fill_cctv(x, y, 2);
        fill_cctv(x, y, 3);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        break;
```
Cctv 4의 경우만 보자. (0, 1, 2, 3 순서대로 오른쪽, 왼쪽, 아래, 위를 의미)

Cctv4에서 보는 각 방향에 따라서 cctv가 닿는 곳에 -1을 넣어준다.
그리고나서 Dfs(cnt+1)를 들어가서 다음 cctv를 본다.

dfs가 끝나면 이전의 배열로 다시 만들어주고 다시 다른 방향을 본다. 이렇게 전체 방향에 대한 완전탐색을 진행한다.


아직 많이 부족하다!!!!
