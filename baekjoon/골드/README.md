# 알고리즘 설명! (골드) (스터디용은 제외)
## 16236. 아기 상어 (골드 4)
어렵다… 응용이 왜이렇게 안될까… 열심히 풀어야겠다….ㅠㅠ

### 구현
1. 현재 위치에서 bfs 하기
2. bfs에서 먹을 수 있는 물고기를 eating vector에 넣는다.
3. 만약 0이거나 사이즈가 같으면 그냥 check만 해주고 queue에만 넣는다.
4. bfs가 끝나면 check배열 초기화하고 만약 eating 배열이 비어있지 않다면 (먹을게 있다면) eat++, tt+=eating[0].first, 먹은 곳은 0으로 처리해주고 아기 상어의 위치도 현재 먹은 위치로 업데이트 해준다.

여기서 tt는 전체 걸린 시간인데, 전역으로 tt++을 해줬더니 같은 시간으로 이동했지만 다른 위치에 있는 경우에 먼저 본 경우가 시간이 더 짧은 경우가 생겼다.

그래서 queue<pair<**int**, pair<**int**, **int**>>> q; 로 queue를 선언하고 가장 앞의 부분을 time으로 넣어주고, eating배열에 넣을 때 시간도 같이 넣어줘서 eating배열에서 뺄때 tt값을 더해줬다.

6. 만약 eating배열이 비었다면 더 이상 먹을게 없다는 말이니까 while문을 나간다.

### 사족
처음에 풀때 엄청 헤맸다. 한번의 bfs로 어떻게든 해보려고 용쓰다가 못하겠어서 거의 포기 직전까지 갔었다….

체크배열을 사용하면 이전에 체크되어 있는 곳은 못가고 체크 배열을 사용하지 않으면 무한루프돌고…..

친구가 그럼 체크배열을 초기화하고 다시 bfs를 돌면 어때? 라고 해주지 않았다면 시간이 오래 지나고 난 후에야 풀 수 있었을 것이다….

고착된 방식에서 머물러 있지 않고 방식의 추가나 제거에 대해서 좀 더 넓게 생각해야겠다는 생각(?)을 했다.



## 15683. 감시 (골드 5)
처음에는 현재의 cctv위치 사방을 보고 최대로 많이 볼 수 있는 방향으로 cctv의 방향을 설정했다. (모든 cctv에 대해서)

이렇게 하면 현재는 가장 많이 0을 채울 수 있을 지는 몰라도 전체적으로 봤을때는 최적의 답이 아닐 수 있게 된다.
```cpp
반례
4 6
2 6 0 3 0 2
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 6 1
8
```

그래서 dfs를 이용해서 전체의 경우의 수를 봐서 완전탐색으로 문제를 풀었다.
```cpp
case 4:
        fill_cctv(x, y, 0);
        fill_cctv(x, y, 1);
        fill_cctv(x, y, 3);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        fill_cctv(x, y, 0);
        fill_cctv(x, y, 2);
        fill_cctv(x, y, 3);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        fill_cctv(x, y, 0);
        fill_cctv(x, y, 1);
        fill_cctv(x, y, 2);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        fill_cctv(x, y, 1);
        fill_cctv(x, y, 2);
        fill_cctv(x, y, 3);
        dfs(cnt+1);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                arr[i][j] = tmp[i][j];
            }
        }
        break;
```
Cctv 4의 경우만 보자. (0, 1, 2, 3 순서대로 오른쪽, 왼쪽, 아래, 위를 의미)

Cctv4에서 보는 각 방향에 따라서 cctv가 닿는 곳에 -1을 넣어준다.
그리고나서 Dfs(cnt+1)를 들어가서 다음 cctv를 본다.

dfs가 끝나면 이전의 배열로 다시 만들어주고 다시 다른 방향을 본다. 이렇게 전체 방향에 대한 완전탐색을 진행한다.


아직 많이 부족하다!!!!

## 2580. 스도쿠 (골드 4)
0인 부분만 따로 zero벡터에 넣어서 진행했다.

0인 부분에 숫자 1~9를 차례대로 넣어보고 만약 넣는게 가능하다면 해당 숫자를 넣고 dfs를 들어갔다. 나왔을때는 꼭 0으로 초기화해줘야 한다.

체크를 할 때는 가로,세로,정사각형을 본다.

코드는 아래와 같다.
```cpp
bool checkSquare(int x, int y, int num){
    for(int i=x/3*3; i<x/3*3+3; i++){
        for(int j=y/3*3; j<y/3*3+3; j++){
            if(arr[i][j] == num)
                return false;
        }
    }
    return true;
}

bool checkLine(int x, int y, int num){
    // 가로
    for(int i=0; i<9; i++){
        if(arr[x][i] == num){
            return false;
        }
    }
    // 세로
    for(int i=0; i<9; i++){
        if(arr[i][y] == num){
            return false;
        }
    }
    return true;
}
```
* 정사각형 : 각각의 인덱스는 무조건 (0, 3, 6)부터 시작해야 하고, (3, 6, 9) 보다 작아야 한다.

파라미터로 들어오는 x, y값을 3으로 나누면 정사각형에 있는 숫자들은 다 같은 값을 가지게 되는데 이것을 이용하면 된다.

예를 들어서 x,y가 4,6이고 3으로 나누면 각각 1, 2이다. 
여기에 3을 곱하면 각각의 시작 인덱스가 나오고 거기에 3을 더하면 마지막 인덱스가 나온다. x의 경우 : 3 ~ 6(6은 포함 안함), y의 경우 : 6 ~ 9(9는 포함 안함)

이렇게 해서 만약 num이 존재 하면 그냥 return false 해버린다.

* 가로, 세로 : 가로 세로는 간단하게, x축만 움직이고, y축만 움직이는 식으로 진행하면 된다.

## 1939. 중량제한 (골드 4)
### 이분탐색 + bfs
입력 값 중 가장 큰 엣지 값을 Max값으로 가진다.

그리고 이 값을 물품의 무게라고 생각하고 이분 탐색을 진행한다.

만약 mid값 무게를 가지고 시작 지점에서 끝 지점으로 갈 수 있다면 mid 이후의 무게를 보고, 그렇지 않다면 mid 이전의 무게를 본다.

### 사족
처음에는 그냥 이전의 무게만을 가지고 bfs만으로 풀었다. 그런데 틀렸습니다가 나왔다.. 아직 왜 틀렸는지는 잘 모르겠다 좀 더 공부해야 겠다고 생각했다..


### 크루스칼
중량 제한이 큰 순으로 정렬을 하고, 만약 시작지와 도착지가 같은 집합에 속해 있지 않다면 두 노드를 합친다.

그리고 만약 같은 집합에 속해 있다면 바로 For문을 끝낸다. (이미 가장 큰 중량 제한을 찾았으므로)

## 1759. 암호 만들기 (골드 5)
우선 순열 + 증가하는순서로 코드를 짤려면 dfs들어가기 전에 정렬을 먼저 해준다.

모음이 최소 한개 있어야 하고, 자음이 최소 두개 있어야 하니까 파라미터로 현재까지의 갯수를 받도록 하고 현재까지의 String도 받도록 한다.

그리고 string의 수가 l 개면 모음, 자음 갯수를 체크하고 오름차순인지도 체크하고 만약 조건을 모두 충족하면 출력하고 리턴한다.

dfs가 끝나면 모음, 자음 갯수 원래대로 해주고 check를 풀어준다.

## 1261. 알고스팟
### 구현
Priority queue를 이용한다. 

기존의 Max heap인 pq를 Min heap으로 바꾸고, 벽을 가장 적게 부신 부분이 가장 먼저 나오도록 한다.

나머지는 기본 Bfs와 동일!
